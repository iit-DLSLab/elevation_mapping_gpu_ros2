elevation_mapping_node:
  ros__parameters:
    
    #### Frames & topics 
    pose_topic: ''
    map_frame: 'map'                            # The map frame where the odometry source uses. (global/world; /robot_pose_slam is in 'map')
    base_frame: 'base_footprint'                # The robot's base frame. This frame will be a center of the map. (3D body; map window centers here)
    corrected_map_frame: 'map_corrected'        # Published when drift correction is enabled. 

    #### Grid / map geometry 
    resolution: 0.04                            # resolution in m.  (grid cell size; trade detail vs. noise)
    map_length: 8.0                             # map's size in m.  (square local map window side length)

    #### Sensor & outlier handling 
    # lighter point cloud = fewer drops
    voxel_filter_size: 0.12                     # downsample input points (speed vs. detail)
    sensor_noise_factor: 0.1                    # point's noise is sensor_noise_factor*z^2 (z is distance from sensor).  (depth σ grows ~ z²)

    # reject obvious bad returns
    min_valid_distance: 0.25                    # points with shorter distance will be filtered out. (near-field realsense noise)
    max_height_range: 6.0                       # points higher than this value from sensor will be filtered out to disable ceiling. 
    mahalanobis_thresh: 2.5                     # points outside this distance is outlier. (lower = stricter rejection)
    outlier_variance: 0.05                      # if point is outlier, add this value to the cell. (de-weights outliers when fused)

    # Ramped ceiling: reject if z > max(d - ramped_height_range_b, 0)*a + c
    ramped_height_range_a: 0.3                  # if z > max(d - ramped_height_range_b, 0) * ramped_height_range_a + ramped_height_range_c, reject.
    ramped_height_range_b: 0.8                  # if z > max(d - ramped_height_range_b, 0) * ramped_height_range_a + ramped_height_range_c, reject.
    ramped_height_range_c: 0.15                 # if z > max(d - ramped_height_range_b, 0) * ramped_height_range_a + ramped_height_range_c, reject.

    #### Variance / fusion weights 
    average_weight: 0.4                         # fusion weight; higher trusts new data more (faster but noisier)
    time_variance: 0.002                        # add this value when update_variance is called. (models slow drift/dynamics)
    initial_variance: 0.08                      # initial variance for each cell. (first good observation)
    max_variance: 50.0                          # maximum variance for each cell. (numeric safety)

    #### Timings & rates 
    update_variance_fps: 30.0                   # fps for updating variance.
    update_pose_fps: 10.0                       # fps for updating pose and shift the center of map.
    time_interval: 0.1                          # Time layer is updated with this interval.
    map_acquire_fps: 10.0                       # Raw map is fetched from GPU memory in this fps.
    publish_statistics_fps: 2.0                 # Publish statistics topic in this fps.
    recordable_fps: 10.0                        # Recordable fps for pointcloud.

    #### Visibility cleanup / ray tracing 
    max_ray_length: 5.0                         # maximum length for ray tracing. (limits occlusion cleanup range)
    cleanup_step: 0.06                          # subtitute this value from validity layer at visibiltiy cleanup. (stronger clearing if larger)
    cleanup_cos_thresh: 0.9                     # subtitute this value from validity layer at visibiltiy cleanup. (angular gating for clearing)

    #### Drift compensation (uses stable, traversable cells) 
    enable_drift_compensation: False
    drift_compensation_variance_inler: 0.05     # cells under this value is used for drift compensation.
    max_drift: 0.1                              # drift compensation happens only the drift is smaller than this value 
    drift_compensation_alpha: 0.1               # drift compensation alpha for smoother update of drift compensation
    min_height_drift_cnt: 100                   # drift compensation only happens if the valid cells are more than this number.
    position_noise_thresh: 0.01                 # if the position change is bigger than this value, the drift compensation happens.
    orientation_noise_thresh: 0.01              # if the orientation change is bigger than this value, the drift compensation happens.
    position_lowpass_alpha: 0.2                 # lowpass filter alpha used for detecting movements.
    orientation_lowpass_alpha: 0.2              # lowpass filter alpha used for detecting movements.
    traversability_inlier: 0.9                  # cells with higher traversability are used for drift compensation.

    #### Safety / traversability layers 
    dilation_size: 3                            # dilation filter size before traversability filter. (morphological smoothing)
    wall_num_thresh: 20                         # if there are more points than this value, only higher points than the current height are used to make the wall more sharp.
    safe_thresh: 0.7                            # if traversability is smaller, it is counted as unsafe cell.
    safe_min_thresh: 0.4                        # polygon is unsafe if there exists lower traversability than this.
    max_unsafe_n: 10                            # if the number of cells under safe_thresh exceeds this value, polygon is unsafe.

    #### Overlap clearance (multi-floor) 
    overlap_clear_range_xy: 4.0                 # xy range [m] for clearing overlapped area. this defines the valid area for overlap clearance. (used for multi floor setting)
    overlap_clear_range_z: 2.0                  # z range [m] for clearing overlapped area. cells outside this range will be cleared. (used for multi floor setting)

    #### Feature toggles 
    enable_edge_sharpen: False
    enable_visibility_cleanup: true
    enable_overlap_clearance: False
    enable_pointcloud_publishing: True
    enable_drift_corrected_TF_publishing: False # during rosbag playback keep false to avoid TF_OLD_DATA at t=0
    enable_normal_color: False                  # If true, the map contains 'color' layer corresponding to normal. Add 'color' layer to the publishers setting if you want to visualize.
    enable_normal_arrow_publishing: False

    #### Initializer 
    initialize_method: 'linear'                  # Choose one from 'nearest', 'linear', 'cubic'
    initialize_frame_id: ['camera_depth_optical_frame']  # One tf (like ['footprint'] ) initializes a square around it. (matches your PointCloud2 frame; REP-119)
    initialize_tf_offset: [0.0, 0.0, 0.0, 0.0]   # z direction. Should be same number as initialize_frame_id. ([x,y,z,yaw] offset)
    dilation_size_initialize: 2                  # dilation size after the init.
    initialize_tf_grid_size: 1.0                 # This is not used if number of tf is more than 3.
    use_initializer_at_start: True               # Use initializer when the node starts.

    #### Traversability filter 
    use_chainer: False                           # Use chainer as a backend of traversability filter or pytorch. If false, it uses pytorch. pytorch requires ~2GB more GPU memory compared to chainer but runs faster.
    # weight_file: '$(find-pkg-share elevation_mapping_cupy)/config/core/weights.dat'  # Weight file for traversability filter
    weight_file: '/home/ros/workspace/src/elevation_mapping_cupy/elevation_mapping_cupy/config/core/weights.dat'  # Weight file for traversability filter

    #### Upper bound 
    use_only_above_for_upper_bound: False

    #### Default Plugins 
    plugin_config_file: '/home/ros/workspace/src/elevation_mapping_cupy/elevation_mapping_cupy/config/core/plugin_config.yaml'
